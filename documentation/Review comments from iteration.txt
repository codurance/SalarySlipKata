SalarySlipApplicationShould
	- are parameterised tests taking away the readability of tests
	- are they making it compact, simple and easy to understand
	- why are there only acceptance tests and no unit tests
	- concept of Annual Salary is repeated twice in the setup of the tests, is this desired?
	- does the test setup look too verbose?
	- is it easy to read and understand what each parameter of the createSalarySlip() contains
	- employee creation is repeated - can be extracted into a common method
	- there's repetition in the setup of the tests

NationalInsuranceCalculatorShould
	- the tests are inputting values as annual salary and checking for its monthly equivalent - is this coherent, as the tables contain values at the Annual Salary level?

TaxCalculatorShould
	- the tests are inputting values as annual salary and checking for its monthly equivalent - is this coherent, as the tables contain values at the Annual Salary level?

SalarySlipApplication
	- the monthly calculation on the salary of the employee stands out - is this the right place for it?
	- are all the calls to methods at the same level of abstraction?
	- are all the variables named well and at the same level?
	- are the order of the statements coherent?
	- is the SalarySlip getting all the data at the right level?
	- employee.annualSalary() is repeated in every call made - is this duplication or can it be extracted into a variable an reused?
	- is it better to say calculateMonthlySalaryOf(employee); or calculateMonthlySalaryOf(employee.annualSalary()); ?

Money
	- the name seems close to what it should be
	- are all the 3 constructors in the right level
	- are all the method at the same level
	- are all the methods doing the right thing?
	- are the conversion between double, Money and BigDecimal correct and happening coherently and efficiently

SalarySlip
	- are the fields grouped well
	- are they at the same level
	- is the combination making up a SalarySlip

TaxDetails
	- are the fields grouped well
	- does it need unit tests?

NationalInsuranceCalculator
	- is it in the right package?
	- class might come across a bit complex [ev(G)=3,iv(G)=3,v(G)=3]
	- there is repetition or duplication across the if blocks in the calculateContributionsFor() function
	- calculateMonthlyContributionsFor() function is it at the right level?
	- are all the constants named correctly
	- could this be converted into a class with more cohesive method calls between each other
	- constants could be converted into a Map/Array?
	- calculateContributionsFor() function could be more generic/extendable?
	- following the above comments, if class is reduced to use generic code, is it clearer and a better win over the existing implementation, is this generalisation needed at this point? Will it help extend the class in future, is it a bit of Designing Upfront? Or overengineering? Maybe its still simpler and more readable now and might become less readable later on, its worth investing in it to find out the design benefits and if it is worth the effort.
	- why are there no unit tests, before refactoring best to write unit tests?
	- is the calculations for excess in the right place? Is it explaining how the calculation is taking place.

TaxCalculator
	- is it in the right package?
	- class might come across a bit more complex than expected [ev(G)=4,iv(G)=4,v(G)=4]
	- there is repition or duplication across the if blocks in the calculateContributionsFor() function
	- calculateMonthlyTaxDetailsFor() function is it at the right level?
	- are all the constants named correctly
	- could this be converted into a class with more cohesive method calls between each other
	- constants could be converted into a Map/Array?
	- calculateTaxPayableFor() function could be more generic/extendible?
	- following the above comments, if class is reduced to use generic code, is it clearer and a better win over the existing implementation, is this generalisation needed at this point? Will it help extend the class in future, is it a bit of Designing Upfront? Or overengineering? Maybe its still simpler and more readable now and might become less readable later on, its worth investing in it to find out the design benefits and if it is worth the effort.
	- why are there no unit tests, before refactoring best to write unit tests?
	- is the calculations for excess in the right place? Is it explaining how the calculation is taking place.

Template of questions
---------------------
1. Does my code violate any of the SOLID principles? If yes, where? why? Is it a problem? How could I fix it? Do I need to fix it?
2. Does my code violate any other principle? If yes, where? why? Is it a problem? How could I fix it? Do I need to fix it?
3. Are there any code smells? If yes, where? why? Is it a problem? How could I fix it? Do I need to fix it?
4. Naming (package, class, method, variables, parameters, etc)
5. Are my tests descriptive enough?
